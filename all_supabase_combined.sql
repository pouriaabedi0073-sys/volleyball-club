-- ALL_SUPABASE_COMBINED.SQL
-- Minimal backup-focused schema for snapshot-based sync
-- Drops legacy hybrid-sync tables if present and creates new tables + RLS policies

-- SECTION 0: Drop legacy objects (best-effort)
DO $$
BEGIN
  -- Drop legacy tables/functions if they exist (harmless if absent)
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'devices') THEN
    EXECUTE 'DROP TABLE IF EXISTS public.devices CASCADE';
  END IF;
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'backup_data_chunks') THEN
    EXECUTE 'DROP TABLE IF EXISTS public.backup_data_chunks CASCADE';
  END IF;
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sync_log') THEN
    EXECUTE 'DROP TABLE IF EXISTS public.sync_log CASCADE';
  END IF;
  -- Remove legacy functions/triggers commonly used by syncHybrid/supabaseSync
  BEGIN
    EXECUTE 'DROP FUNCTION IF EXISTS public.process_outbox() CASCADE';
  EXCEPTION WHEN OTHERS THEN NULL; END;
  BEGIN
    EXECUTE 'DROP FUNCTION IF EXISTS public.old_mark_shared_backup(text, text) CASCADE';
  EXCEPTION WHEN OTHERS THEN NULL; END;
END$$;

-- SECTION 1: Create core tables for snapshot backup flow
CREATE TABLE IF NOT EXISTS public.backups (
  id text PRIMARY KEY,
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  group_email text,
  storage_path text NOT NULL,
  size_bytes bigint,
  snapshot_summary jsonb,
  created_at timestamptz DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.shared_backups (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  group_email text NOT NULL,
  backup_id text REFERENCES public.backups(id) ON DELETE CASCADE,
  created_at timestamptz DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.backup_groups (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  group_email text UNIQUE,
  created_at timestamptz DEFAULT now()
);

-- SECTION 2: Indexes
CREATE INDEX IF NOT EXISTS idx_backups_group_email ON public.backups (lower(group_email));
CREATE INDEX IF NOT EXISTS idx_shared_backups_group ON public.shared_backups (lower(group_email));

-- SECTION 3: RLS and policies
-- Enable RLS on backups and shared_backups
ALTER TABLE public.backups ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.shared_backups ENABLE ROW LEVEL SECURITY;

-- Add explicit owner-based policies for backups to ensure auth.uid() checks
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='backups' AND policyname='backups_insert_own') THEN
    EXECUTE 'CREATE POLICY "backups_insert_own" ON public.backups FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id)';
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='backups' AND policyname='backups_select_own') THEN
    EXECUTE 'CREATE POLICY "backups_select_own" ON public.backups FOR SELECT TO authenticated USING (auth.uid() = user_id)';
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='backups' AND policyname='backups_update_own') THEN
    EXECUTE 'CREATE POLICY "backups_update_own" ON public.backups FOR UPDATE TO authenticated USING (auth.uid() = user_id)';
  END IF;
END$$;

-- Ensure shared_backups has at least a read policy for authenticated users
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='shared_backups' AND policyname='shared_backups_select_all') THEN
    EXECUTE 'CREATE POLICY "shared_backups_select_all" ON public.shared_backups FOR SELECT TO authenticated USING (true)';
  END IF;
END$$;

-- Allow authenticated users to INSERT backups where auth.uid() = user_id
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='backups' AND policyname='allow_insert_authenticated') THEN
    EXECUTE 'CREATE POLICY allow_insert_authenticated ON public.backups FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id)';
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='backups' AND policyname='allow_select_own') THEN
    EXECUTE 'CREATE POLICY allow_select_own ON public.backups FOR SELECT TO authenticated USING (auth.uid() = user_id)';
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='backups' AND policyname='allow_delete_own') THEN
    EXECUTE 'CREATE POLICY allow_delete_own ON public.backups FOR DELETE TO authenticated USING (auth.uid() = user_id)';
  END IF;
END$$;

-- shared_backups: allow insert/select by authenticated (server-side RPC will manage latest pointer)
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='shared_backups' AND policyname='allow_insert_all') THEN
    EXECUTE 'CREATE POLICY allow_insert_all ON public.shared_backups FOR INSERT TO authenticated WITH CHECK (true)';
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='shared_backups' AND policyname='allow_select_all') THEN
    EXECUTE 'CREATE POLICY allow_select_all ON public.shared_backups FOR SELECT TO authenticated USING (true)';
  END IF;
END$$;

-- SECTION 4: mark_shared_backup RPC (updates shared_backups.latest pointer)
CREATE OR REPLACE FUNCTION public.mark_shared_backup(p_group_email text, p_backup_id text)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
  INSERT INTO public.shared_backups (group_email, backup_id, created_at)
  VALUES (lower(p_group_email), p_backup_id, now())
  ON CONFLICT (group_email) DO UPDATE SET backup_id = EXCLUDED.backup_id, created_at = now();
END; $$;

-- SECTION 5: cleanup: remove data/operation columns from any older backups table
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='backups' AND column_name='data') THEN
    BEGIN
      EXECUTE 'ALTER TABLE public.backups DROP COLUMN IF EXISTS data';
    EXCEPTION WHEN OTHERS THEN NULL; END;
  END IF;
  IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='backups' AND column_name='operation') THEN
    BEGIN
      EXECUTE 'ALTER TABLE public.backups DROP COLUMN IF EXISTS operation';
    EXCEPTION WHEN OTHERS THEN NULL; END;
  END IF;
END$$;

-- End of migration
-- ======================================================================
-- ALL_SUPABASE_COMBINED.SQL
-- Ultra-minimal schema for JSON-based backups. Only 3 core tables:
-- 1. profiles: RLS enforcement via group_email
-- 2. backups: metadata for compressed JSON snapshots
-- 3. shared_backups: group-level backup discovery
--
-- App data lives entirely in compressed JSON snapshots stored in Storage.
-- ======================================================================

-- Section 1: Extensions
CREATE SCHEMA IF NOT EXISTS public;

DO $$
BEGIN
  BEGIN EXECUTE 'CREATE EXTENSION IF NOT EXISTS "pgcrypto"'; EXCEPTION WHEN OTHERS THEN RAISE NOTICE 'pgcrypto: %', SQLERRM; END;
END$$;

-- Section 2: Core tables (only 3)
CREATE TABLE IF NOT EXISTS public.profiles (
  id uuid PRIMARY KEY,
  email text,
  group_email text
);

CREATE TABLE IF NOT EXISTS public.backups (
  id text PRIMARY KEY,
  group_email text NOT NULL,
  storage_path text,            -- path inside Storage bucket (e.g. "group@example.com/backup-2025-.. .gz")
  snapshot_summary jsonb,       -- {tables: ['players',...], row_counts: {players: 50,...}, total_size_kb: 45}
  created_at timestamptz DEFAULT now(),
  revision integer DEFAULT 1,
  size_bytes integer
);

CREATE TABLE IF NOT EXISTS public.shared_backups (
  group_email text PRIMARY KEY,
  latest_backup_id text REFERENCES public.backups(id) ON DELETE SET NULL,
  updated_at timestamptz DEFAULT now()
);

-- Section 3: Indexes and simple dedupe
DO $$
DECLARE
  dup_count integer := 0;
  dup_details text;
BEGIN
  -- Simple pre-check for duplicates
  WITH dupes AS (
    SELECT lower(group_email) AS g, revision, COUNT(*) as cnt,
           string_agg(id || ' @ ' || created_at::text, ', ' ORDER BY created_at DESC) as detail
    FROM public.backups 
    WHERE group_email IS NOT NULL
    GROUP BY lower(group_email), revision
    HAVING COUNT(*) > 1
  )
  SELECT string_agg(
    format('Group: %s, Rev: %s has %s dupes: %s', g, revision, cnt - 1, detail),
    E'\n'
  ) INTO dup_details
  FROM dupes;

  IF dup_details IS NOT NULL THEN
    RAISE WARNING 'Found duplicates that need cleanup:%', E'\n' || dup_details;
  END IF;

  -- Simple dedupe: Keep newest per (group,rev), delete others directly
  WITH latest AS (
    SELECT DISTINCT ON (lower(group_email), revision) 
      id
    FROM public.backups
    WHERE group_email IS NOT NULL
    ORDER BY lower(group_email), revision, created_at DESC, id DESC
  )
  DELETE FROM public.backups b
  WHERE NOT EXISTS (
    SELECT 1 FROM latest l WHERE l.id = b.id
  );

  GET DIAGNOSTICS dup_count = ROW_COUNT;
  IF dup_count > 0 THEN
    RAISE NOTICE 'Removed % duplicate backups (kept newest per group+revision)', dup_count;
  END IF;

  -- Create unique indexes (backups and shared_backups only)
  IF NOT EXISTS (SELECT 1 FROM pg_class c WHERE c.relkind='i' AND c.relname='idx_backups_group_rev') THEN
    BEGIN
      -- Try CONCURRENTLY if supported (reduces locking)
      EXECUTE 'CREATE UNIQUE INDEX CONCURRENTLY idx_backups_group_rev ON public.backups (lower(group_email), revision)';
    EXCEPTION WHEN OTHERS THEN
      RAISE WARNING 'Failed to create index CONCURRENTLY: % - trying non-concurrent create', SQLERRM;
      BEGIN
        CREATE UNIQUE INDEX idx_backups_group_rev ON public.backups (lower(group_email), revision);
      EXCEPTION WHEN OTHERS THEN
        RAISE WARNING 'Failed to create unique index: % - check for remaining duplicates', SQLERRM;
      END;
    END;
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_class c WHERE c.relkind='i' AND c.relname='idx_shared_backups_group') THEN
    CREATE UNIQUE INDEX idx_shared_backups_group ON public.shared_backups (lower(group_email));
  END IF;
END$$;

-- Section 4: Row Level Security (RLS) Policies
-- Enable RLS on all tables and set up group-based access
DO $$
BEGIN
  -- Enable RLS on all tables
  BEGIN EXECUTE 'ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY'; EXCEPTION WHEN OTHERS THEN RAISE NOTICE 'RLS profiles: %', SQLERRM; END;
  BEGIN EXECUTE 'ALTER TABLE public.backups ENABLE ROW LEVEL SECURITY'; EXCEPTION WHEN OTHERS THEN RAISE NOTICE 'RLS backups: %', SQLERRM; END;
  BEGIN EXECUTE 'ALTER TABLE public.shared_backups ENABLE ROW LEVEL SECURITY'; EXCEPTION WHEN OTHERS THEN RAISE NOTICE 'RLS shared_backups: %', SQLERRM; END;

  -- Profiles: Users can only see/modify profiles in their group
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='profiles' AND policyname='profiles_group_policy') THEN
    CREATE POLICY profiles_group_policy ON public.profiles
    FOR ALL
    TO authenticated
    USING (
      lower(group_email) = lower(current_setting('jwt.claims.email', true))
      OR
      lower(email) = lower(current_setting('jwt.claims.email', true))
    )
    WITH CHECK (
      lower(group_email) = lower(current_setting('jwt.claims.email', true))
      OR
      lower(email) = lower(current_setting('jwt.claims.email', true))
    );
  END IF;

  -- Backups: Users can only access backups for their group
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='backups' AND policyname='backups_group_policy') THEN
    CREATE POLICY backups_group_policy ON public.backups
    FOR ALL
    TO authenticated
    USING ( lower(group_email) = lower(current_setting('jwt.claims.email', true)) )
    WITH CHECK ( lower(group_email) = lower(current_setting('jwt.claims.email', true)) );
  END IF;

  -- Shared backups: Users can only see/update shared backups for their group
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='shared_backups' AND policyname='shared_backups_group_policy') THEN
    CREATE POLICY shared_backups_group_policy ON public.shared_backups
    FOR ALL
    TO authenticated
    USING ( lower(group_email) = lower(current_setting('jwt.claims.email', true)) )
    WITH CHECK ( lower(group_email) = lower(current_setting('jwt.claims.email', true)) );
  END IF;

  -- Grant access to authenticated users
  GRANT ALL ON public.profiles TO authenticated;
  GRANT ALL ON public.backups TO authenticated;
  GRANT ALL ON public.shared_backups TO authenticated;
END$$;

-- Section 5: Helper to purge old backups while preserving the latest per group_email
CREATE OR REPLACE FUNCTION public.purge_old_backups(keep_days integer DEFAULT 7)
RETURNS integer LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
  cutoff timestamptz := now() - (keep_days || ' days')::interval;
  deleted_count integer := 0;
BEGIN
  -- For each group_email, keep the newest backup regardless of age
  WITH latest AS (
    SELECT lower(group_email) AS g, max(created_at) AS maxt
    FROM public.backups
    GROUP BY lower(group_email)
  )
  DELETE FROM public.backups b
  WHERE b.created_at < cutoff 
  AND NOT EXISTS (
    SELECT 1 FROM latest l 
    WHERE lower(b.group_email) = l.g 
    AND b.created_at = l.maxt
  );
  
  -- Get exact number of rows deleted
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;

EXCEPTION WHEN OTHERS THEN
  RAISE WARNING 'purge_old_backups failed: %', SQLERRM;
  RETURN -1;
END; $$;

-- Section 7: Small convenience RPC for clients to upsert shared_backups entry
CREATE OR REPLACE FUNCTION public.mark_shared_backup(p_group_email text, p_backup_id text)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
  INSERT INTO public.shared_backups(group_email, latest_backup_id, updated_at)
  VALUES (lower(p_group_email), p_backup_id, now())
  ON CONFLICT (group_email) DO UPDATE SET latest_backup_id = EXCLUDED.latest_backup_id, updated_at = now();
END; $$;

-- Cleanup RPC: keep only the 5 most recent backups per group_email
CREATE OR REPLACE FUNCTION public.cleanup_old_backups(p_email text)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
  DELETE FROM public.backups
  WHERE id IN (
    SELECT id FROM public.backups
    WHERE group_email = p_email
    ORDER BY created_at DESC
    OFFSET 5
  );
END; $$;

-- End of backup-focused schema
